You are an autonomous senior full-stack engineer working inside this repository (Rust backend + Next.js App Router UI). Your mission is to implement the entire plan in `Rustyfin_Playback_Final_Agent_Plan.md` for build 8024266, using `Rustyfin_Playback_Deep_Dive_8024266.md` and `Rustyfin_Playback_Deep_Dive_Critique_8024266.md` as supporting context.

CRITICAL RULES (to prevent hallucinations / partial work)
1) Grounding: Do not assume any endpoint, struct field, DB table, or UI selector exists. Before coding, locate the exact file(s) with ripgrep and open them. Any claim you make must correspond to real code in this repo.
2) No TODOs, no placeholders, no “later”. If you touch an area, finish it to production quality.
3) If you discover a mismatch between the docs and repo, prefer the repo as truth and update implementation accordingly while still achieving the plan’s intent.
4) Security is non-negotiable:
   - Do NOT ship unauthenticated HLS endpoints.
   - Do NOT put long-lived auth tokens in URLs (query strings leak via logs/history/referrers). Tokens are sensitive and must be protected from disclosure.  :contentReference[oaicite:1]{index=1}
5) Verification: You must run tests/builds locally and fix failures before finishing.

PRIMARY OBJECTIVES (Definition of Done)
A) Playback works end-to-end:
   - Clicking Direct Play triggers actual network requests and plays when browser supports it.
   - Clicking Transcode (HLS) triggers session creation + playlist + segments and plays in-browser.
   - Player never “does nothing” silently; it shows clear errors and disables invalid actions.

B) Security is fixed (P0):
   - /stream/hls/* requires auth + authorization on every request (playlist + segments).
   - The primary auth JWT is NOT passed in URLs. If streaming needs a URL token, it must be a short-lived, scoped stream token (or switch to same-origin HttpOnly cookie auth).

C) Libraries are reliable:
   - Library creation rejects invalid/unreadable paths immediately (field-level validation).
   - Scan detects media from fixture directories and ensures item->file mapping exists so playback can resolve file_id.

D) Automated tests exist to prove the above:
   - Backend tests for playback descriptor + HLS auth.
   - E2E test that creates a library, scans fixture media, and confirms stream requests occur.

WORK PLAN (must execute in order; do not skip)
Stage 0 — Baseline evidence
1) Read these three files first and summarize the required changes as a checklist:
   - Rustyfin_Playback_Final_Agent_Plan.md
   - Rustyfin_Playback_Deep_Dive_8024266.md
   - Rustyfin_Playback_Deep_Dive_Critique_8024266.md
2) Reproduce the current failure locally (buttons do nothing) and identify the exact call chain in the repo.

Stage 1 — Fix API ↔ Player contract (unblocks playback)
1) Implement a dedicated endpoint: GET /api/v1/items/{id}/playback (“Playback Descriptor”).
   - It must return file_id for playable items, plus direct/HLS URLs (but no primary JWT in URL).
   - It must enforce library access and return a clear error if item has no mapped file.
2) Update Player page to call this playback descriptor and:
   - show clear errors if file_id missing
   - disable buttons when invalid
   - remove any silent early returns

Stage 2 — Fix the HLS auth vulnerability (P0)
1) Add auth requirements to both HLS handlers (master playlist and segment fetch).
2) Bind each transcode session to user_id and file_id at creation time.
3) On each HLS request, verify the authenticated user matches the session owner (and any additional access checks you need).
4) Unauthenticated HLS requests must return 401/403.

Stage 3 — Remove “JWT in URL” and implement safe streaming auth
Choose ONE secure approach and implement it fully:
Option A (preferred if feasible): Same-origin HttpOnly cookie auth for streaming.
Option B (minimum-change): Mint a short-lived, scoped stream token (TTL 30–120s, scoped to file_id/session_id, audience “stream”).
- Do NOT reuse the main auth JWT in query strings; query strings leak sensitive data. :contentReference[oaicite:2]{index=2}
- Add headers to reduce leakage/caching (e.g., Cache-Control: no-store; Referrer-Policy).
- Update UI to use the new auth mechanism for direct play and HLS URLs.

Stage 4 — Improve Direct Play reliability (MIME + capability + fallback)
1) Align content-type mapping with scanner allowlist (only add what’s actually missing; do not “fix” things already present).
2) In the player, implement a modern decision strategy:
   - Prefer Media Capabilities API when available; fallback to canPlayType; fallback to runtime error (video.onerror) to auto-switch to HLS.
(Keep it robust: direct play when it works, auto-HLS when it doesn’t.)

Stage 5 — Transcoder robustness + observability
1) Make ffmpeg/ffprobe paths configurable and validate presence.
2) Ensure max-concurrent-transcodes is actually enforced (do not drop concurrency permits prematurely).
3) Improve error messages surfaced to UI for common failures (missing ffmpeg, unreadable input, unwritable output).

Stage 6 — Library correctness
1) Add fail-fast validation of library paths on creation/update (absolute, exists, dir, readable) with field-level errors paths[i].
2) Ensure scan writes item->file mapping consistently (verify DB repo functions used by playback descriptor).

Stage 7 — Tests (required)
Backend:
- Test GET /items/{id}/playback returns file_id for mapped items and errors for unmapped.
- Test HLS endpoints:
  - unauthenticated => 401/403
  - authenticated owner => 200
  - authenticated non-owner => 403
E2E (Playwright or equivalent already used in this repo):
- Create library using fixture media path, scan, open item, click Direct Play => assert stream request happens.
- Click HLS => assert session POST happens and playlist/segments are requested.

REQUIRED COMMANDS (run and fix until green)
- Rust: cargo fmt --all ; cargo clippy --workspace --all-targets -- -D warnings ; cargo test
- UI: npm --prefix ui install ; npm --prefix ui run lint ; npm --prefix ui run build
- E2E tests: run whatever harness exists in this repo (or add one if missing) and show results.

FINAL DELIVERABLE (your final response must include)
1) A file-by-file change list (added/modified/deleted).
2) The exact commands you ran and their results (tests/builds).
3) A brief “How to verify manually” checklist (what URLs to click and what network calls should appear).
4) Any security decisions (cookie auth vs short-lived stream token) and why, in 5–10 lines max.

Now do the work. Do not stop early. Do not leave anything unfinished.